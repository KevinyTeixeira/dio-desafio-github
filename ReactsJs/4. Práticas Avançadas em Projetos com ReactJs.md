# ðŸ“š PrÃ¡ticas AvanÃ§adas em Projetos com ReactJs

Content...



## 1. :alien: `React Hooks`

â€‹	O `React Hooks` depende e muito do entendimento sobre o **Ciclo de Vida** do React, portanto, se sentir dificuldade, retorne para a a aula do "**3. Desenvolvimento de AplicaÃ§Ãµes para Internet com ReactJs**", quando falamos sobre os ciclos em `Stateful`. Entretanto para efeitos de registro, os mais utilizados sÃ£o:

- **`componentDidMount:`** Ã© executado depois que a saÃ­da do componente Ã© renderizada no DOM. Este Ã© um bom lugar para configurar por exemplo, um temporizador.
- **`componentDidUpdate:`** Ã© chamado imediatamente apÃ³s a atualizaÃ§Ã£o ocorrer. Este mÃ©todo nÃ£o Ã© chamado para a renderizaÃ§Ã£o inicial.
- **`componentWillUnmount:`** ideal para interromper completamente a execuÃ§Ã£o de um componente na aplicaÃ§Ã£o, para que nÃ£o consuma a mÃ¡quina desnecessariamente.
- **`shouldComponentUpdate:`** cria condicionais para definir quando um componente deve ser atualizado, baseando-se no retorno booleano `true` ou `false`.



**O que sÃ£o `Hooks`?**

â€‹	Foram adicionados ao React na sua versÃ£o **16.8**, eles permitem que vocÃª utilize estados e propriedades de uma forma muito mais clara, sem utilizar classes. Os `Hooks` mais utilizados sÃ£o:

- useState;
- useEffect;
- useContext;
- useReducer;
- useCallback
- useMemo;
- useRef;
- useImperativeHandle;
- useLayoutEffect;
- useDebugValue;



Para ficar mais claro algumas mudanÃ§as, vamos aplicar uma comparaÃ§Ã£o.

```javascript
// EXAMPLE 1: DIO code example, BEFORE hooks update!
// OBJ: to compare code with hooks, and without hooks

import React, { Component } from 'react'

class Twitter extends Component {
    
    state = {
        tweet: 'title'
    }
    
    componentDidMount()  {
        const { posts, loading } = this.props
        console.log('componentDidMount', posts)
        console.log('componentDidMount: loading', loading)
    }
    
    componentDidUpdate(prevProps) {
        const { loading } = this.props
        if (this.props.loading !== prevProps.loading) {
            console.log('componentDidUpdate:loading', loading)
        }
    }
        
	componentWillUnmount() {
        console.log('componentWillUnmount: fui removido :(')
    }
    
    shouldComponentUpdate(nextProps, nextState) {
        return this.state.tweet !== nextState.tweet
    }
    
    tweet = () => {
        .this.setState({
            tweet: true
        })
    }

    render () {
        const { posts } = props
        console.log('render', posts)
        return (
            <div>
                <button onClick= { tweet }>Re-render</button>
                test
            </div>
        )
	}
}

export default Twitter
```

```javascript
// EXAMPLE 2: DIO code example, AFTER hooks update!
// OBJ: compare code with hooks, and without hooks

/* 
HIGHLIGHTING CHANGES
1. Import COMPONENT not is needed anymore;
2. We don't use classes anymore;
3. '.this' is unnecessary;
4. To render the COMPONENT, only the 'return()' still necessary, the 'render()' call now is dispensable;
5. To manipulate lifecycles or states, now we can use React Hooks like 'useEffect', memo;
*/

import React, { useEffect, useState, memo } from 'react'

	// shouldComponentUpdate (using memo Hooks, must pass this function by argument on export!)
    const areEqual = (prevProps, nextProps) => { // if the component props change, will re-render!
        return prevProps.loading === nextProps.loading;
    }
    
function Twitter(props) { // we don't use classes anymore
    const { loading } = props // to use on componentDidUpdate
    const { tweet, setTweet } = useState() // we already learn about this hook 
        
    // componentDidMount
	useEffect(() => { // useEffect(function, array[functions useds, param to return for this life cycle])
        const { posts, loading } = props
        console.log('componentDidMount', posts)
        console.log('componentDidMount: loading', loading)
    }, [/* If empty, will only run once */])
    
	// componentDidUpdate
	useEffect(() => {
        console.log('componentDidUpdate', loading)
    }, [loading]) // when loading change, will execute this lifecycle
    
	// componentWillUnmount
	useEffect(() => {
        return () => {
        	console.log('componentWillUnmount: fui removido :(')
    	}
    }, [])
  
    // changeState
    const handleTweet = () => {
        setTweet('Tweet atualizado')
    }
    
    console.log('Tweet atualizado: ', tweet)
	return (
    	<div>
        	<button onClick= { handleTweet }>Re-render</button>
    		test
        </div>
    )
}

export default memo(Twitter, areEqual);
```

â€‹	Com isso, percebemos que o **`React Hooks`** realmente veio para facilitar a programaÃ§Ã£o!
