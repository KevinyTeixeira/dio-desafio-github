# üìö Pr√°ticas Avan√ßadas em Projetos com ReactJs

## 1. :alien: Aprofundando Sobre o Ciclo de Vida do React

### 1.1  `Ciclo de Vida`

‚Äã	O `React Hooks` depende e muito do entendimento sobre o **Ciclo de Vida** do React, portanto, se sentir dificuldade, retorne para a a aula do "**3. Desenvolvimento de Aplica√ß√µes para Internet com ReactJs**", quando falamos sobre os ciclos em `Stateful`. Entretanto para efeitos de registro, os mais utilizados s√£o:

- **`componentDidMount:`** √© executado depois que a sa√≠da do componente √© renderizada no DOM. Este √© um bom lugar para configurar por exemplo, um temporizador.
- **`componentDidUpdate:`** √© chamado imediatamente ap√≥s a atualiza√ß√£o ocorrer. Este m√©todo n√£o √© chamado para a renderiza√ß√£o inicial.
- **`componentWillUnmount:`** ideal para interromper completamente a execu√ß√£o de um componente na aplica√ß√£o, para que n√£o consuma a m√°quina desnecessariamente.
- **`shouldComponentUpdate:`** cria condicionais para definir quando um componente deve ser atualizado, baseando-se no retorno booleano `true` ou `false`.



### 1.2`React Hooks` 

**O que s√£o `Hooks`?**

‚Äã	Foram adicionados ao React na sua vers√£o **16.8**, eles permitem que voc√™ utilize estados e propriedades de uma forma muito mais clara, sem utilizar classes. Os `Hooks` mais utilizados s√£o:

- useState;
- useEffect;
- useContext;
- useReducer;
- useCallback
- useMemo;
- useRef;
- useImperativeHandle;
- useLayoutEffect;
- useDebugValue;



Para ficar mais claro algumas mudan√ßas, vamos aplicar uma compara√ß√£o.

```javascript
// EXAMPLE 1: DIO code example, BEFORE hooks update!
// OBJ: to compare code with hooks, and without hooks

import React, { Component } from 'react'

class Twitter extends Component {
    
    state = {
        tweet: 'title'
    }
    
    componentDidMount()  {
        const { posts, loading } = this.props
        console.log('componentDidMount', posts)
        console.log('componentDidMount: loading', loading)
    }
    
    componentDidUpdate(prevProps) {
        const { loading } = this.props
        if (this.props.loading !== prevProps.loading) {
            console.log('componentDidUpdate:loading', loading)
        }
    }
        
	componentWillUnmount() {
        console.log('componentWillUnmount: fui removido :(')
    }
    
    shouldComponentUpdate(nextProps, nextState) {
        return this.state.tweet !== nextState.tweet
    }
    
    tweet = () => {
        .this.setState({
            tweet: true
        })
    }

    render () {
        const { posts } = props
        console.log('render', posts)
        return (
            <div>
                <button onClick= { tweet }>Re-render</button>
                test
            </div>
        )
	}
}

export default Twitter
```

```javascript
// EXAMPLE 2: DIO code example, AFTER hooks update!
// OBJ: compare code with hooks, and without hooks

/* 
HIGHLIGHTING CHANGES
1. Import COMPONENT not is needed anymore;
2. We don't use classes anymore;
3. '.this' is unnecessary;
4. To render the COMPONENT, only the 'return()' still necessary, the 'render()' call now is dispensable;
5. To manipulate lifecycles or states, now we can use React Hooks like 'useEffect', memo;
*/

import React, { useEffect, useState, memo } from 'react'

	// shouldComponentUpdate (using memo Hooks, must pass this function by argument on export!)
    const areEqual = (prevProps, nextProps) => { // if the component props change, will re-render!
        return prevProps.loading === nextProps.loading;
    }
    
function Twitter(props) { // we don't use classes anymore
    const { loading } = props // to use on componentDidUpdate
    const { tweet, setTweet } = useState() // we already learn about this hook 
        
    // componentDidMount
	useEffect(() => { // useEffect(function, array[functions useds, param to return for this life cycle])
        const { posts, loading } = props
        console.log('componentDidMount', posts)
        console.log('componentDidMount: loading', loading)
    }, [/* If empty, will only run once */])
    
	// componentDidUpdate
	useEffect(() => {
        console.log('componentDidUpdate', loading)
    }, [loading]) // when loading change, will execute this lifecycle
    
	// componentWillUnmount
	useEffect(() => {
        return () => {
        	console.log('componentWillUnmount: fui removido :(')
    	}
    }, [])
  
    // changeState
    const handleTweet = () => {
        setTweet('Tweet atualizado')
    }
    
    console.log('Tweet atualizado: ', tweet)
	return (
    	<div>
        	<button onClick= { handleTweet }>Re-render</button>
    		test
        </div>
    )
}

export default memo(Twitter, areEqual);
```

‚Äã	Com isso, percebemos que o **`React Hooks`** realmente veio para facilitar a programa√ß√£o!



## 2. :cyclone: T√©cnicas Avan√ßadas com Componentes

‚Äã	Fragmentos, Error Boundaries, Render, Typechecking com PropTypes, Refs e DOM

### **2.1 `Fragments`**

‚Äã	Um padr√£o comum no `React` √© que um componente pode retornar m√∫ltiplos elementos. Os Fragmentos permitem agrupar uma lista de filhos sem adicionar n√≥s extras ao DOM.

‚Äã	Para ficar mais claro, perceba que para renderizar os componentes, temos utilizado `<div>` a fim de encapsular tudo em um √∫nico retorno. Entretanto, j√° imaginou o caos que ficaria nosso render, sabendo que cada componente possuir√° sua `div`, e dentro desta `div` poder√° haver outras `divs`? Por isso utilizamos o **`fragment`**, ele remove os <div> pais, que n√£o possuem a necessidade de aparecerem.

‚Äã	Para aplicar o **`Fragment`**, existem 3 formas:

```javascript
// OBJ: use one, of 3 fragment methods in our app to render without unnecessary <divs>

import React from 'react'

// 1¬∫ Method: <> </>
// 2¬∫ Method: <React.Fragment> </React.Fragment>
// 3¬∫ Method: <Fragment> </Fragment>

function App() {
    return (
    	<Fragment>
			<div>
	        	ReactJS Avan√ßado
			</div>
        </Fragment>
    )
}
```

‚Äã	Voc√™ se lembra, do c√≥digo implementado no conte√∫do de **Introdu√ß√£o ao React**, no qual ao utilizar listas, o `React` exigia que cada elemento tivesse uma **`key`**? Tamb√©m podemos aproveitar o fragment para facilitar essa implementa√ß√£o.

```javascript
// OBJ: create a list with keys using fragment

import React from 'react'

function Column() {
    return(
    	<tr>
        	<td>Tennis</td>
        	<td>Clothes</td>
        </tr>
    )
}

function App() {
    
    const renderColumns = (key) => (
        <Fragment key={`column-${key}`}>
        	<Column />
		</Fragment>
    )
    return (
    	<table>
			{store.map(renderColumns)}
        </table>
    )
}
```



### **2.2 `Error Boundaries`**

‚Äã	A premissa √© que caso ocorra **um erro de JavaScript** em uma parte da UI, **n√£o deve quebrar toda a aplica√ß√£o**. Para resolver esse problema para usu√°rios do `React`, o React 16 introduziu um novo conceito, conhecito como **`Error Boundary`**.

‚Äã	O **`ErrorBoundary`** √© um componente que tem por objetivo, **receber, identificar e tratar os erros de toda a aplica√ß√£o**, geralmente retornando um feedback ao usu√°rio. N√≥s criamos o componente, e em seguida o importamos no **`Index.js`**, para que toda a aplica√ß√£o esteja "amparada" pelo **`ErrorBoundary`**. Por fim, em todo retorno dos componentes, inserimos a tag `<ErrorBoundary>` `</ErrorBoundary>` para que nosso render esteja amparado.

```javascript
// COMPONENT: Index.js
// OBJ: Implement an ErrorBoundary component, and use it;

import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'
import ErrorBoundary from './ErrorBoundary'

ReactDom.render(
	<App />,
    docment.getElementById('root')
)
```

```javascript
// COMPONENT: ErrorBoundary.js
// OBJ: Implement an ErrorBoundary component, and use it;

// This component will be responsible by catch and handling errors;
import React, { Component } from 'react'

class ErrorBoundary extends Component {
    constructor(props){
        super(props)
        this.state = {
            hasError: false
        }
    }
    
	componentDidCatch(error, errorInfo) { // Catch the error and print it
        console.log('error', error)
        console.log('errorInfo', errorInfo)
        this.setState({
            hasError: true // give error
        })
    }
    
    return() {
        if(thi.state.hasError) { <!-- feedbackuser -->
            return <p>Sorry, something went wrong!</p> 
        }
        return this.props.children
    }
}

export default ErrorBoundary
```

```javascript
// COMPONENT: App.js
// OBJ: Implement an ErrorBoundary component, and use it;

import React, { Fragment } from 'react'

const store = [{
    type: 'Clothes'
}, {
    type: 'Shoes'
}, {
    type: 'Shirts'
}]

function Column({ type }) {
    return ( <!-- type.name.window will result an error, becase name property don't exist! -->
    	<tr>
        	<td>{ type.name.window }</td> 
        </tr>
    )
}

function App() {
    
    const renderColumns = (key) => (
        <Fragment key={`column-${key}`}>
        	<Column />
		</Fragment>
    )
    
    return (
    	<ErrorBoundary> <!-- Calling ErrorBoundary Component -->
            <table>
                { store.map(renderColumns) }
            </table>
    	</ErrorBoundary> <!-- Calling ErrorBoundary Component -->
    )
}
```



### **2.3 `Render Props`**

‚Äã	O termo **`render prop`** se refere a uma t√©cnica de **compartilhar c√≥digo entre componentes** `React` passando uma **prop cujo valor √© uma fun√ß√£o**.

‚Äã	Um componente com uma **`render prop`** recebe uma fun√ß√£o que retorna um elemento `React` e a invoca no momento da renderiza√ß√£o, n√£o sendo necess√°rio para o componente implementar uma l√≥gica pr√≥pria. Vamos ver como funciona na pr√°tica para melhor compreens√£o:

```javascript
// COMPONENT: Counter.js (render prop)
// OBJ: Implement an render prop component, and use it;

// This component will be responsible by implement some possible functions for all components, called "render prop";

// Have 2 methods, increment and decreament, and receive 'count: 0';

import React, { Component } from 'react'

class Counter extends Component {
    
    constructor(props) {
        super(props)
        this.state = {
            count: 0
        }
    }
    
    increment = () => {
        const { count } = this.state
        this.setState({
            count: count + 1
        })
    }
    
    decrement = () => {
        const { count } = this.state
        this.setState({
            count: count - 1
        })
    }
    
    render() {
        const { render } = this.props
        const { count } = this.state
        
        return (
        	<>
                {
				render ({
					// these 3 functions can be used by our components
					increment: this.increment,
					decrement: this.decrement,
					count
				})
                }
			</>
        )
    }
}
```

```javascript
// COMPONENT: App.js
// OBJ: Implement an render prop component, and use it;

import React, { Component } from 'react'
import Counter from './Counter' // import our render prop

const Buttons = ({ increment, decrement, count }) => (
	<>
    	<h1>Valor atual: {count}</h1>
		<div>
    		<button onClick={increment}>Adicionar 1</button>
		</div>
		<div>
			<button onClick={decrement}>Remover 1</button>
		</div>
    </>
)

class App extends Component {
    
    render() {
        return(
        	<>
            	<Counter render= {
            		({ increment, decrement, count }) => (
        			<Buttons
            			increment = { increment }
            			decrement = { decrement }
            			count = { count }
					/>
        		)
			}>
			</Counter>
            </>
        )
    }
}
```



