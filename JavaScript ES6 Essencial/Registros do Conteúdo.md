# üìö JavaScript ES6 Essencial

Aqui registrarei todos os conte√∫dos que eu considerar importante nessa disciplina, algo como um bloco de *"Anota√ß√µes"* para que eu possa retornar futuramente caso considere necess√°rio.

Acesse o **[documento de estudo do JavaScript ES6 Avan√ßado]()** para mais detalhes pr√°ticos da programa√ß√£o em s√≠.

## üìë Caracter√≠sticas do JavaScript

Antes de mais nada, JavaScript n√£o √© uma variante de Java. Foi criada por Brendan Eich em 1995. Agora vamos come√ßar com as caracter√≠sticas do Java:

#### 1Ô∏è‚É£ JavaScript, √© uma linguagem interpretada!

Aqui voc√™ precisa entender os termos **interpretado** e **compilados**, os compilados s√£o as linguagens que precisam converter o c√≥digo em um arquivo diferente para que seja interpretado, a exemplo do java que gera um bytecode (.class) ou do C++ que converte o c√≥digo em assembler. No caso do JavaScript, o c√≥digo n√£o precisa ser transformado.

#### 2Ô∏è‚É£ JavaScript, t√™m Tipagem Fraca e Din√¢mica!

Essas duas caracter√≠sticas s√£o muito importantes quando se trata de programar nessa linguagem. A **Tipagem Fraca** significa dizer que os "tipos" das vari√°veis n√£o precisam ser declaradas para que voc√™ possa usa-las, essa declara√ß√£o √© feita automaticamente quando a vari√°vel recebe um valor. Ou seja, se for um texto, automaticamente ela se tornar√° "string".

Al√©m disso, o termo **Din√¢mico**, refere-se ao fato de que esse "tipo" n√£o √© imut√°vel, voc√™ pode em um dado momento, declarar que a vari√°vel recebe um n√∫mero, e logo em seguida declarar que ela deve receber uma string.

#### 3Ô∏è‚É£ JavaScript, trabalha com Fun√ß√µes de 1¬™ Classe e Ordem Maior!

Isso significa dizer, que as fun√ß√µes podem ser atribu√≠das a uma vari√°vel, a uma estrutura de dados (object, array) e podem ser passada por argumentos!

```javascript
/* Exemplo: */
function getName() {
    return 'Keviny Teixeira de Jesus';
}

function logFn(fn) {
    console.log(fn());
}

const logFnResult = logFn;

logFnResult(getName);
```

#### 4Ô∏è‚É£ JavaScript √© capaz de "lembrar" do "escopo" em que a fun√ß√£o foi criada!

Sim, e isso se chama **Closure**! Esse conceito nada mais √© do que a capacidade do JavaScript em levar em considera√ß√£o defini√ß√µes que estejam foram da fun√ß√£o diretamente mencionada. Isso deve ter ficado bem confuso, mas vamos dar um exemplo:

```javascript
/* Exemplo: */
/* Vamos considerar dois arquivos JavaScript */

/* Arquivo de ESCOPO.js */
let x = 50

function somarXMais3() {
    return x + 3
}

/* Arquivo de MAIN.js */
let x = 100
console.log(somarXMais3())
```

Certo, agora eis a pergunta, em **Main.js** n√≥s definimos o valor de X = 100, e em **Escopo.js** est√° definido o valor de X = 50, qual dos dois valores de X ser√° considerado na hora de somar o valor de X na fun√ß√£o? Pois√©, se voc√™ acha que √© como Java, est√° enganado. Aqui o resultado **ser√° 53!** üòÜ

Vamos complicar um pouco mais, veja o cen√°rio abaixo:

```javascript
/* Exemplo: */
/* Vamos somente atualizar nosso ESCOPO.js */

/* Arquivo de ESCOPO.js */
let x = 50

function fora () {

	function somarXMais3() {
		return x + 3
	}
	return somarXMais3
}
```

Certo, a pergunta √© a seguinte, at√© aonde o **Closure** nessa fun√ß√£o leva o "Escopo Externo" em considera√ß√£o, nesse caso ele levar√° somente at√© a fun√ß√£o fora, ou ainda sim tentar√° procurar o valor de x fora da fun√ß√£o "fora"? Mais uma vez, o resultado **ser√° 53!** üòÜ

Isso ocorre porque **ao n√£o encontrar o valor de x no escopo da fun√ß√£o fora, ele tenta procurar tamb√©m no escopo subsequente**. √ìbviamente isso tamb√©m significa que caso houvesse um valor de x sendo definido no escopo fora, ele √© quem seria considerado!

## üìëConceitos Importantes do JavaScript

- **Currying:** cria uma outra fun√ß√£o dentro de uma fun√ß√£o j√° existente, permitindo que um dos par√¢metros utilizados possam usar declara√ß√µes simplificadas.
  - :globe_with_meridians: **[Exemplo de Currying](link)**;
- **Hoisting:** permite que uma vari√°vel ou fun√ß√£o seja utilizada, mesmo que esta ainda n√£o tenha sido "lida" pela execu√ß√£o do c√≥digo. Isso impede que o c√≥digo apresente um erro, entretanto o valor da vari√°vel √© mostrado como "Undefined". O Hoisting **tamb√©m pode ser aplicado em fun√ß√µes**, com o √∫nico diferencial de que para as fun√ß√µes.
  - :globe_with_meridians: **[Exemplo de Hoisting](link)**;
- **Imutabilidade:** √© um conceito que prev√™ a imutabilidade de objetos. Quando voc√™ tenta inserir um novo atributo a um objeto, ao inv√©s de acrescent√°-lo, o JavaScript cria um novo objeto, c√≥pia do √∫ltimo e inclui o novo atributo.
  - :globe_with_meridians: **[Exemplo de Imutabilidade](link)**;

## :earth_americas: A import√¢ncia de entender o ESCOPO do JavaScript

Cuidado! Nada do que foi dito acima ir√° importar, se voc√™ n√£o entender o comportamento dos conceitos dentro dos escopos de programa√ß√£o do JavaScript, isso porque na melhor das hip√≥teses, voc√™ simplesmente n√£o entender√° o comportamento do que est√° sendo executado. Veja como √© a defini√ß√£o de escopos:

```javascript
/* DEFINI√á√ÉO DE ESCOPOS */

var exemplo= "teste"; /* Aqui √© o ESCOPO GLOBAL */

{
	console.log = exemplo; /* Aqui √© o ESCOPO DE BLOCO */
}

function addText() {
    /* Aqui √© o ESCOPO DE FUN√á√ÉO */
}
```

‚Äã	H√° 3 tipos de vari√°veis no JavaScript, s√£o elas: `var`, `let`, `const`. Veja alguns de seus comportamentos:

- O **var**, n√£o respeita um escopo de bloco. Utilizando do conceito de **hoisting**, ele ir√° procurar a vari√°vel no escopo global ou no escopo de fun√ß√£o, caso sua declara√ß√£o n√£o tenha sido encontrada no escopo de bloco;

  ```javascript
  var test = 'exemplo'; 
  
  (() => {
  	console.log('Valor dentro da fun√ß√£o "${test}"'); /* Nesse momento, o valor √© "undefined", o que significa que a vari√°vel foi encontrada, mas o valor n√£o foi definido nesse escopo. */
  	
  	if (true) {
  		test = 'exemplo';
  		console.log('Valor dentro do if "${test}"');
  	}
  	
  	console.log('Valor ap√≥s a execu√ß√£o do if "${test}"');
  })();
  
  /* SA√çDA */
  Valor dentro da fun√ß√£o "undefined"
  Valor dentro da if "example"
  Valor ap√≥s a execu√ß√£o do if "example"
  ```

- O **let**, respeita todos os escopos, o que significa que a vari√°vel s√≥ existir√° dentro do escopo em que foi definida.

  ```javascript
  (() => {
  	let test = 'valor da fun√ß√£o';
  	console.log('Valor dentro da fun√ß√£o "${test}"');
  	
  	if (true) {
  		let test = 'valor if';
  		console.log('Valor dentro do if "${test}"');
  	}
  	
  	if (true) {
  		let test = 'valor de outro if';
  		console.log('Valor dentro do if "${test}"');
  	}
  	
  	console.log('Valor ap√≥s a execu√ß√£o do if "${test}"');
  })();
  
  /* SA√çDA */
  Valor dentro da fun√ß√£o "valor fun√ß√£o"
  Valor dentro da if "valor if"
  Valor ap√≥s a execu√ß√£o do if "valor fun√ß√£o"
  ```

- O **const**, respeita todos os escopos, o que significa que a vari√°vel s√≥ existir√° dentro do escopo em que foi definida. Entretanto, uma declara√ß√£o nativa n√£o poder√° ter seu valor alterado, salvo que esse valor seja dentro de um objeto.

  ```javascript
  const name = 'Keviny';
  
  // N√£o podemos alterar o valor
  name = 'Keviny';
  
  const user = {
  	name: 'Keviny'
  };
  
  // Mas se for um objeto, podemos trocar suas propriedades
  user.name = 'Outro nome';
  
  // N√£o podemos fazer o objeto "apontar" para outro lugar
  user = {
  	name: 'Keviny'
  };
  
  const persons = ['Keviny', 'Keuvyn', 'David'];
  
  //Podemos adicionar novos itens
  persons.push('Ana'); /* ['Keviny', 'Keuvyn', 'David', 'Ana'] */
  
  // Podemos remover algum item
  persons.shift(); /* ['Keviny', 'Keuvyn', 'David'] */
  
  // Podemos alterar diretamente;
  persons[1] = 'Ant√¥nio'; /* ['Keviny', 'Ant√¥nio', 'David'] */
  
  console.log('/nArray Ap√≥s as altera√ß√µes: ', persons);
  
  /* SA√çDA */
  Valor dentro da fun√ß√£o "valor fun√ß√£o"
  Valor dentro da if "valor if"
  Valor ap√≥s a execu√ß√£o do if "valor fun√ß√£o"
  ```



## :dart: Tipos e Vari√°veis no JavaScript

‚Äã	O JavaScript, na data deste documento possui atualmente **6 tipos de vari√°veis primitivas**, e **3 tipos de objetos**. Al√©m de list√°-los aqui, tamb√©m irei incluir os comandos mais utilizados dentro de cada tipo de vari√°vel, entretanto, esses exemplos ser√£o linkados a um arquivo externo dentro do reposit√≥rio, a fim de n√£o poluir de mais este resumo.

1. `string`; 
   - Veja aqui os **[comandos mais utilizados de STRING](link)**;
2. `number`;
   - Veja aqui os **[comandos mais utilizados de NUMBER](link)**;
3. `boolean`;
   - Veja aqui os **[comandos mais utilizados de BOOLEAN](link)**;
4. `null`;
   - Veja aqui os **[comandos mais utilizados de NULL](link)**;
5. `undefined`;
   - Veja aqui os **[comandos mais utilizados de UNDEFINED](link)**;
6. `symbol`;
   - Veja aqui os **[comandos mais utilizados de SYMBOL](link)**;
7. `object`;
   - Veja aqui os **[comandos mais utilizados de OBJECT](link)**;
8. `function`;
   - Veja aqui os **[comandos mais utilizados de FUNCTION](link)**;
9. `array`;
   - Veja aqui os **[comandos mais utilizados de ARRAY](link)**;
